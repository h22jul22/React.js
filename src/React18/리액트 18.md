### 자동 배칭 (Automatic Batching)

-   배칭(batching) → 여러 state의 업데이트가 동시에 발생할때 여러 작업을 묶어서 한 번에 처리하는 작업
-   기존 리액트에서는 **이벤트 핸들러 내부**의 state update 작업에 대해서만 Batching 이 가능
    -   하지만 Promise나 setTimeout, Native Event Handler 내부의 작업은 불가능
    -   왜냐하면 이전에는 **브라우저의 이벤트가 실행되는 중에만 Batching 작업을 수행**했기 때문에 이벤트가 종료된 후에 실행되는 경우는 Batching 작업이 불가능
-   리액트 18에서 자동 배칭(Automatic Batching)이라는 기능이 새롭게 등장
    -   자동으로 여러 state의 업데이트 작업을 묶어서 한번에 처리
    -   단순히 이벤트 핸들러 내부 뿐만이 아니라 Promise나 setTimeout, Native Event Handler 같은 작업에 대해서도 **Batching 작업을 자동으로** 수행
    ```jsx
    // 기존 버전
    setTimeout(() => {
        setCount((count) => count + 1); // 리렌더링 유발
        setIsFull((isFull) => !isFull); // 리렌더링 유발
        // 각 state의 업데이트마다 재렌더링이 발생
    }, 1000);

    // v18 이후
    setTimeout(() => {
        setCount((count) => count + 1);
        setIsFull((isFull) => !isFull);
        // 재렌더링이 마지막에 한 번만 발생
    }, 1000);
    ```

### 트랜지션 (Transitions)

-   리액트에서 긴급한 업데이트와 긴급하지 않은 업데이트를 구분해서 처리하기 위해 등장한 새로운 개념
    -   React 애플리케이션에서는 여러 상태 업데이트가 동시에 발생할 수 있음 → Transition은 이러한 문제를 해결하기 위해 도입 → 어떤 상태 변화를 Transition(`startTransition()` 혹은 `useTransition()`)으로 표시함으로써, 사용자 입력과 같은 바로 처리되어야 하는 상태 변화와 상대적으로 느려도 문제가 없는 상태 변화를 구분
    -   사용자에게 더 빠르고 더 나은 사용자 경험을 제공하기 위해서
    -   각종 업데이트가 서로 다른 우선순위를 가지고 효율적으로 관리될 수 있음
-   긴급한 업데이트
    -   사용자와 직접적인 인터렉션이 일어나는 경우
    -   예) 글자 입력, 버튼 클릭 등
-   긴급하지 않은 업데이트
    -   사용자와 직접적인 인터렉션이 일어나지 않는 경우
    -   예) 서버에서 결과를 받아와 보여 주는 경우
    -   긴급하지 않은 업데이트로 처리되는 경우 더 긴급한 업데이트가 발생하면 중단될 수 있음
    ```jsx
    import { startTransition } from 'react';

    // 긴급 업데이트: 입력한 글자를 화면에 보여줘야 함
    setInputValue(input);

    // 함수 내에 있는 모든 업데이트는 transition 업데이트가 됨
    startTransition(() => {
        // Transition 업데이트: 검색 결과를 보여줘야 함
        setSearchQuery(input);
    });
    ```

### 서스펜스 (Suspense)

-   하위 컴포넌트(children)가 준비되기 전까지 렌더링을 중단하고, 하위 컴포넌트가 준비된 이후에 렌더링을 진행 → 사용자 경험을 향상시켜줌.
-   기존에는 클라이언트에서 Suspense가 Code Splitting과 함께 제한적으로 사용되었지만, 리액트 18부터 서버 렌더링과 Data Fetching(제한적으로)에서도 사용할 수 있게 되었다.
    -   서버에서 페이지의 일부가 느리게 준비되더라도 사용자는 점진적으로 로딩되는 페이지를 볼 수 있음.
    -   또한 lazy 컴포넌트가 아직 준비되지 않았지만 Suspense로 래핑 된 경우, 리액트는 청크 파일이 로드될 때까지 기다리지 않고 이미 렌더링 된 부분들을 hydrate 할 수 있음.
    ```jsx
    import { lazy, Suspense } from 'react';
    import LoadingSpinner from './LoadingSpinner';
    const OtherComponent = lazy(() => import('./OtherComponent'));

    function MyComponent(props) {
    	return (
    		<Suspense fallback={<LoadingSpinner />}>
    			<OtherComponent />
    		</Suspens>
    	);
    }

    export defalt MyComponent;
    ```

### 리액트 DOM 서버

-   서버에서 동작하고 렌더링 된다는 특성상 다양한 종류의 백엔드 리소스에 접근할 수 있고 HTML이 아닌 ‘특별한’ 형태로 렌더링 되어 클라이언트에 전달되기 때문에 클라이언트로 전달되는 번들 사이즈 또한 감소시킬 수 있다.
-   서버 컴포넌트는 서버에서 동작하기 때문에 데이터베이스, 파일 시스템 그리고 인터널 서비스 같은 서버 사이드 데이터 소스에 직접 접근할 수 있다.
-   서버 컴포넌트 코드는 브라우저에 다운로드되지 않고 서버에서 미리 렌더링 된 static content를 전달하기 때문에 패키지를 추가해도 번들 사이즈에 영향을 끼치지 않는다.
-   유저 인터랙션이 없는 컴포넌트들을 서버 컴포넌트로 마이그레이션 한다면 동일한 뷰를 제공함과 동시에 번들 사이즈와 초기 로딩 시간을 감소시킬 수 있다.
-   Code splitting을 서버 컴포넌트에서
    -   서버 컴포넌트에서 import 되는 모든 클라이언트 컴포넌트를 code splitting 포인트로 간주하기 때문에 더 이상 `React.lazy`로 메뉴얼 하게 명시하지 않아도 된다.
    -   서버에서 미리 필요한 컴포넌트를 선택하기 때문에 클라이언트는 렌더링 프로세스 초기에 번들을 다운로드할 수 있다.
-   리액트 서버 컴포넌트의 도입으로 기존 컴포넌트는 목적에 따라 서버(data fetching), 클라이언트(유저 인터랙션) 그리고 공유 컴포넌트로 세분화할 수 있다.
    -   클라이언트 컴포넌트는 파일 시스템 접근과 같은 server-only feature를 사용할 수 없다.
    -   클라이언트 컴포넌트는 다른 클라이언트 컴포넌트만 import할 수 있다.
    -   서버 컴포넌트는 state와 같은 client-only feature를 사용할 수 없다.
-   리액트 서버 컴포넌트(RSC)와 서버 사이드 렌더링(SSR)
    -   리액트 서버 컴포넌트는 서버 사이드 렌더링의 대체재가 아니다. 하지만 사용자 경험 향상을 위해 함께 사용할 수는 있다.
    -   서버 컴포넌트와 서버 사이드 렌더링은 서버에서 렌더링 된다는 유사점이 있지만 해결하고자 하는 문제점이 다르다.
    -   서버 컴포넌트의 코드는 클라이언트로 전달되지 않는다. 하지만 서버 사이드 렌더링의 모든 컴포넌트의 코드는 자바스크립트 번들에 포함되어 클라이언트로 전송된다.
    -   서버 컴포넌트는 클라이언트 상태를 유지하며 refetch 될 수 있다. 서버 컴포넌트는 HTML이 아닌 특별한 형태로 컴포넌트를 전달하기 때문에 필요한 경우 포커스, 인풋 입력값 같은 클라이언트 상태를 유지하며 여러 번 데이터를 가져오고 리렌더링하여 전달할 수 있다. 하지만 SSR의 경우 HTML로 전달되기 때문에 새로운 refetch가 필요한 경우 HTML 전체를 리렌더링 해야 하며 이로 인해 클라이언트 상태를 유지할 수 없다.
    -   서버 컴포넌트는 서버 사이드 렌더링 대체가 아닌 보완의 수단으로 사용할 수 있다. 서버 사이드 렌더링으로 초기 HTML 페이지를 빠르게 보여주고, 서버 컴포넌트로는 클라이언트로 전송되는 자바스크립트 번들 사이즈를 감소시킨다면 사용자에게 기존보다 훨씬 빠르게 인터랙팅한 페이지를 제공할 수 있을 것이다.
-   서버 컴포넌트를 사용한다면 클라이언트 data fetching의 큰 문제점인 네트워크 waterfall을 해결할 수 있다.
-   더불어 번들 사이즈 감소, 다양한 백엔드 data source 사용, 자동 코드 분할, 컴포넌트 별 관심사 분리 등 다양한 이점으로 사용자 경험뿐만이 아니라 개발자 경험 또한 향상될 수 있다.

### 새로운 Strict 모드 작동 방식

-   React 18에서는 useEffect가 여러번 실행될 때 멱등성을 보장하는것을 표면적으로 보여지도록 하기위해 즉 렌더링 횟수에따라 결과가 바뀌는 것을 방지하기 위해 Strict Mode에 해당 기능을 추가하였다.
-   Strict Mode는 Effect의 **setup** > **cleanup** > **setup** 로직을 실행하여, 특히 컴포넌트가 변경될 때마다 발생할 수 있는 버그를 찾아내는 데 유용하며 이를 통해 컴포넌트의 멱등성을 어느정도 보장해준다.
-   컴포넌트 생명주기 함수가 예상과 다르게 여러 번 호출될 수 있는데, 이러한 점을 잘 인지하고 컴포넌트가 여러 번 마운트되어도 문제가 생기지 않도록 개발하는 것이 중요하다.
